
This file is to include your testing documentation. The file is to be
in plain text ASCII and properly spaced and edited so that when it is
viewed on a Linux machine it is readable. Not all ASCII files created
on a Windows machine display as expected due to the differences with
respect to how new lines and carriage returns are treated. Line widths
are to be limited to 80 characters.


=====================================================================
                              TESTS                                       
=====================================================================

Note: Most of our tests are fully automated. I'll try to put references to the
      places in the code where the tests run because looking at that is much
      better than looking at the output (we don't really have much output unless
      there's a failure).


#1 - Test showing prioritization and signals interrupting each other
====================================================================
See signal.c:539 for code

TEST: 
 - Create 2 signal handlers
    - one prints "I'm lower priority"
    - the other prints "I'm higher priority"
- Call syssighandler & register both the handlers:
    - the lower priority handler is registered as signal 3
    - the higher priority handler is registered as signal 5
- Signal a signal 3 with syskill()
- Handler for signal 3 signals signal 5

EXPECT: "I'm a higher priority" should be printed before 
"I'm a lower priority" is. 
RESULT: PASSES

#2 - syssighandler() test case
====================================================================
See signal.c:524 for code

TEST:
- Attempt to pass in old_handler pointer at an invalid address

EXPECT: Should return -3 to indicate that old_handler is at invalid address
RESULT: PASSES


#3 - syskill() test case 
====================================================================
See signal.c:541 for code

TEST:
- Attempt to signal default behaviour

EXPECT:
- No handler should be run. 
RESULT: PASSES


#4 - syswait() test case
====================================================================
See signal.c:601 for code

TEST:
- Attempt to wait on a non-existent process

EXPECT: 
- Should return -1
RESULT: PASSES


#5 - sysopen() with invalid arguments
====================================================================
See kbd.c:592 for code

TEST:
- Attempt to open on device 12

EXPECT: 
- Should return -1
RESULT: PASSES


#6 - syswrite() with invalid file descriptor
====================================================================
See kbd.c:610 for code

TEST:
- Attempt to do a syswrite to fd 20 

EXPECT:
- Should return -1
RESULT: PASSES


#7 - sysioctl() test for invalid arguments 
====================================================================
See kbd.c:619 for code

TEST:
- Call sysioctl() with 60 as command number

EXPECT: 
- Should return -1
RESULT: PASSES


#8 - sysread() when there are more characters buffered  in kernel than read
               requests
====================================================================
TEST:
- Create a process that does a syssleep for 10 seconds
- While the process is sleeping, pound away at the keyboard
    - make note of the first key you press 
    - by the time the process wakes up, the kernel buffer should
    be full of ASCII characters from the keyboard
- Have the process that was sleeping do a sysread for a single character

EXPECT: 
- Since the kernel buffers up to 4 characters, a read request for a single
character should cause the first character we pressed to get copied into
the process buffer. 
- We expect that the first keypress prior to the other ones should 
get copied into the buffer of the user. 
RESULT: PASSES


#9 - Two test cases for scenarios not covered here or in the test program. 
====================================================================
See kbd.c:673 for code

TEST:
    - Create a process that simulates a user typing on the keyboard. It
      basically just populates the kernel buffer in the same way a hardware
      interrupt would. (Triggers the same sequence of events)
    - Have this process send an EOF character
    - In another process do a sysread on the keyboard.

EXPECT:
    The return value should be 0, but not only that, everytime you read from the
    keyboard you should get and EOF return code from sysread (0). This effect
    can be cancelled by closing and opening the file descriptor.

RESULT:
    PASSES
    We verify the above claim by reading multiple times after the first EOF and
    asserting the return value is zero every time.


See signal.c:688 for code

TEST:
    - Have a signal handler send the same signal to itself. E.g., receive signal
      for signal 8, start handler, handler then signals itself signal 8 again.

EXPECT:
    - The signal handler should run twice.
    - In addition, the first occurrence of the handler should NOT be interrupted
Result:
    PASSES
    - We verify that the first occurrence is not interrupted by using an if
      statement to detect which run is currently going off. See signal.c:653.
